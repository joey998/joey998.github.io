(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{392:function(t,e,a){"use strict";a.r(e);var n=a(40),l=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"publicpath和filename"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#publicpath和filename"}},[t._v("#")]),t._v(" publicPath和filename")]),t._v(" "),a("p",[t._v("首先明确一点"),a("br"),t._v("\nwebpack打包后的文件是没有../../以及多层父元素的，只有当前目录（./）和根目录（/）"),a("br"),t._v("\n再明确一点"),a("br"),t._v("\n插件里面可以定义filename（类似output.filename，可以指定存放目录）\nLoader里面可以定义publicPath（用来定义某文件里面的根路径，替换文件里面的/或者./）")]),t._v(" "),a("p",[t._v("所以，对于使用了某插件以及某loader时候，首先会把文件存放在了filename定义的地方，\n然后会用publicPath来替换掉文件中的各种路径（相对路径，绝对路径等等）。")]),t._v(" "),a("p",[t._v("所以对于设置了publicPath的loader资源，基本上是对不上的。需要我们手动调整打包之后的资源。")]),t._v(" "),a("p",[t._v("比如我们在output.publicPath里面添加了”/ddd/”，没有改变filename，\n那么打包后的资源目录结构相对之前是没有变得，\n但是，文件里面的资源引用是有问题的，基本上都加上了/ddd/(path)，\n所以，要想正常运行，我们要在根目录新建一个/ddd/目录，然后然后将所以处理过的资源放到/ddd/目录下面")]),t._v(" "),a("p",[a("strong",[t._v("总结：")]),t._v("\nfilename用来指定打包路径，会改变打包后的目录结构。\n而publicPath用来改变文件的引用，不会改变打包后的目录结构，所以我们打包完成之后还要手动调整目录结构，以修正publicPath的影响。")])])}),[],!1,null,null,null);e.default=l.exports}}]);